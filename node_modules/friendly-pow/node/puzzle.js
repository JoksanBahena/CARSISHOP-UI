"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPuzzleTTL = exports.combineSolutions = exports.getPuzzleSolverInputs = exports.PUZZLE_USER_DATA_MAX_LENGTH = exports.PUZZLE_USER_DATA_OFFSET = exports.PUZZLE_NONCE_OFFSET = exports.PUZZLE_DIFFICULTY_OFFSET = exports.NUMBER_OF_PUZZLES_OFFSET = exports.PUZZLE_EXPIRY_OFFSET = exports.PUZZLE_VERSION_OFFSET = exports.APP_ID_OFFSET = exports.ACCOUNT_ID_OFFSET = exports.PUZZLE_TIMESTAMP_OFFSET = void 0;
const encoding_1 = require("./encoding");
const constants_1 = require("./constants");
exports.PUZZLE_TIMESTAMP_OFFSET = 0;
exports.ACCOUNT_ID_OFFSET = 4;
exports.APP_ID_OFFSET = 8;
exports.PUZZLE_VERSION_OFFSET = 12;
exports.PUZZLE_EXPIRY_OFFSET = 13;
exports.NUMBER_OF_PUZZLES_OFFSET = 14;
exports.PUZZLE_DIFFICULTY_OFFSET = 15;
exports.PUZZLE_NONCE_OFFSET = 24;
exports.PUZZLE_USER_DATA_OFFSET = 32;
exports.PUZZLE_USER_DATA_MAX_LENGTH = 32;
function getPuzzleSolverInputs(puzzleBuffer, numPuzzles) {
    const startingPoints = [];
    for (let i = 0; i < numPuzzles; i++) {
        const input = new Uint8Array(constants_1.CHALLENGE_SIZE_BYTES);
        input.set(puzzleBuffer);
        input[120] = i;
        startingPoints.push(input);
    }
    return startingPoints;
}
exports.getPuzzleSolverInputs = getPuzzleSolverInputs;
/**
 * Combine multiple solutions (8 byte values) into a single array
 * @param solutions
 */
function combineSolutions(solutions) {
    const combined = new Uint8Array(solutions.length * 8);
    for (let i = 0; i < solutions.length; i++) {
        combined.set(solutions[i], i * 8);
    }
    return combined;
}
exports.combineSolutions = combineSolutions;
/**
 * Time in seconds the puzzle is valid for.
 * @param puzzleBuffer
 */
function getPuzzleTTL(puzzleBuffer) {
    return encoding_1.expiryToDurationInSeconds(puzzleBuffer[exports.PUZZLE_EXPIRY_OFFSET]);
}
exports.getPuzzleTTL = getPuzzleTTL;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHV6emxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3B1enpsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx5Q0FBdUQ7QUFDdkQsMkNBQW1EO0FBRXRDLFFBQUEsdUJBQXVCLEdBQUcsQ0FBQyxDQUFDO0FBQzVCLFFBQUEsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDO0FBQ3RCLFFBQUEsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNsQixRQUFBLHFCQUFxQixHQUFHLEVBQUUsQ0FBQztBQUMzQixRQUFBLG9CQUFvQixHQUFHLEVBQUUsQ0FBQztBQUMxQixRQUFBLHdCQUF3QixHQUFHLEVBQUUsQ0FBQztBQUM5QixRQUFBLHdCQUF3QixHQUFHLEVBQUUsQ0FBQztBQUM5QixRQUFBLG1CQUFtQixHQUFHLEVBQUUsQ0FBQztBQUN6QixRQUFBLHVCQUF1QixHQUFHLEVBQUUsQ0FBQztBQUU3QixRQUFBLDJCQUEyQixHQUFHLEVBQUUsQ0FBQztBQUU5QyxTQUFnQixxQkFBcUIsQ0FBQyxZQUF3QixFQUFFLFVBQWtCO0lBQ2hGLE1BQU0sY0FBYyxHQUFpQixFQUFFLENBQUM7SUFFeEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNuQyxNQUFNLEtBQUssR0FBRyxJQUFJLFVBQVUsQ0FBQyxnQ0FBb0IsQ0FBQyxDQUFDO1FBQ25ELEtBQUssQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDeEIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNmLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDNUI7SUFDRCxPQUFPLGNBQWMsQ0FBQztBQUN4QixDQUFDO0FBVkQsc0RBVUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixnQkFBZ0IsQ0FBQyxTQUF1QjtJQUN0RCxNQUFNLFFBQVEsR0FBRyxJQUFJLFVBQVUsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3RELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3pDLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUNuQztJQUNELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7QUFORCw0Q0FNQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLFlBQVksQ0FBQyxZQUF3QjtJQUNuRCxPQUFPLG9DQUF5QixDQUFDLFlBQVksQ0FBQyw0QkFBb0IsQ0FBQyxDQUFDLENBQUM7QUFDdkUsQ0FBQztBQUZELG9DQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhwaXJ5VG9EdXJhdGlvbkluU2Vjb25kcyB9IGZyb20gXCIuL2VuY29kaW5nXCI7XG5pbXBvcnQgeyBDSEFMTEVOR0VfU0laRV9CWVRFUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgY29uc3QgUFVaWkxFX1RJTUVTVEFNUF9PRkZTRVQgPSAwO1xuZXhwb3J0IGNvbnN0IEFDQ09VTlRfSURfT0ZGU0VUID0gNDtcbmV4cG9ydCBjb25zdCBBUFBfSURfT0ZGU0VUID0gODtcbmV4cG9ydCBjb25zdCBQVVpaTEVfVkVSU0lPTl9PRkZTRVQgPSAxMjtcbmV4cG9ydCBjb25zdCBQVVpaTEVfRVhQSVJZX09GRlNFVCA9IDEzO1xuZXhwb3J0IGNvbnN0IE5VTUJFUl9PRl9QVVpaTEVTX09GRlNFVCA9IDE0O1xuZXhwb3J0IGNvbnN0IFBVWlpMRV9ESUZGSUNVTFRZX09GRlNFVCA9IDE1O1xuZXhwb3J0IGNvbnN0IFBVWlpMRV9OT05DRV9PRkZTRVQgPSAyNDtcbmV4cG9ydCBjb25zdCBQVVpaTEVfVVNFUl9EQVRBX09GRlNFVCA9IDMyO1xuXG5leHBvcnQgY29uc3QgUFVaWkxFX1VTRVJfREFUQV9NQVhfTEVOR1RIID0gMzI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdXp6bGVTb2x2ZXJJbnB1dHMocHV6emxlQnVmZmVyOiBVaW50OEFycmF5LCBudW1QdXp6bGVzOiBudW1iZXIpOiBVaW50OEFycmF5W10ge1xuICBjb25zdCBzdGFydGluZ1BvaW50czogVWludDhBcnJheVtdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QdXp6bGVzOyBpKyspIHtcbiAgICBjb25zdCBpbnB1dCA9IG5ldyBVaW50OEFycmF5KENIQUxMRU5HRV9TSVpFX0JZVEVTKTtcbiAgICBpbnB1dC5zZXQocHV6emxlQnVmZmVyKTtcbiAgICBpbnB1dFsxMjBdID0gaTtcbiAgICBzdGFydGluZ1BvaW50cy5wdXNoKGlucHV0KTtcbiAgfVxuICByZXR1cm4gc3RhcnRpbmdQb2ludHM7XG59XG5cbi8qKlxuICogQ29tYmluZSBtdWx0aXBsZSBzb2x1dGlvbnMgKDggYnl0ZSB2YWx1ZXMpIGludG8gYSBzaW5nbGUgYXJyYXlcbiAqIEBwYXJhbSBzb2x1dGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVTb2x1dGlvbnMoc29sdXRpb25zOiBVaW50OEFycmF5W10pOiBVaW50OEFycmF5IHtcbiAgY29uc3QgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShzb2x1dGlvbnMubGVuZ3RoICogOCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc29sdXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29tYmluZWQuc2V0KHNvbHV0aW9uc1tpXSwgaSAqIDgpO1xuICB9XG4gIHJldHVybiBjb21iaW5lZDtcbn1cblxuLyoqXG4gKiBUaW1lIGluIHNlY29uZHMgdGhlIHB1enpsZSBpcyB2YWxpZCBmb3IuXG4gKiBAcGFyYW0gcHV6emxlQnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdXp6bGVUVEwocHV6emxlQnVmZmVyOiBVaW50OEFycmF5KSB7XG4gIHJldHVybiBleHBpcnlUb0R1cmF0aW9uSW5TZWNvbmRzKHB1enpsZUJ1ZmZlcltQVVpaTEVfRVhQSVJZX09GRlNFVF0pO1xufVxuIl19